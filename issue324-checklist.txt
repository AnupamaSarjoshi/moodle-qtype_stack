FRESH STUFF 2018-10-16:

Merged all identifier security lists as a single JSON stack/cas/security-map.json.
Dropped/replaced some teacherallow identifiers: atrig1, azimut => azimuth,
eps_height, eps_width, file_bgcolor, maxi, mini (something missing here?),
ntrig, pdf_width, pic_height, pic_width, plot_real_part => plot_realpart,
rot_horizontal, rot_vertical,

For student allow the situation is abit more odd. e.g. why are so many plot
related identifiers allowed for students surely students do not plot? Anyway
in there changed/dropped: nticks => ntics (NOTE! probably needs to be changed
in stack-maxima code too, however both exist in maximas own testcases),
plot_implicit (probably should be implicit_plot?).

Note that the point of the new security map is to provide information about
the identifiers in addition of just classifying them to security classes.
For example, some identifiers will have the 'evfun' feature tagged in
the map and will therefore get considered as function calls if seen as flags,
more importantly all the mapping functions have their own flags there. As do
constants which now can be singled out and writing to them forbidden.



Next step to wrap that file to logic and refactor the old from the code.



FRESH STUFF 2018-10-10:

Going into caskeyval_test, why are we testing keyvals with security='s'? Is
there a case where that happens? If so then the keyval logic with multiline
statements and bulk parsing needs to have the old way as an alternative route
for those that need security='s' and also if not for students we never
insert stars, right?

CJS: Matti, I don't think there is a good reason why caskeyval_test always uses "s" here in the tests.
Looking back at the code, we always have "new stack_cas_keyval" with the teacher option as far as I can see.
I did design this with the possibility that students might be given the "caschat.php" functionality, or we have a "CAS filter",
so something like the keyval functionality should have the "s"/"t" distinction, and be able to pass the various validation options through.

MH response:
  - Depends a bit on what the "s"/"t" distinction means here. If its just
    the security then no problem it already does that. If it includes insert
    stars then it needs to fall back to the previous logic before applying
    insert stars and students with insert stars will not have multi-line
    statements.
  - My understanding is that "t" means no insert stars only log_x style candy.
    And therefore the parser can work iteratively with keyvals to inject
    the missing semicolons, it could not do that if insert stars would compete
    on the same field.

test_keyval_session_keyval_3 and test_keyval_session_keyval_4 cause trouble
in that case as the logic now uses parse errors to identify where to place
semicolons and it cannot deal with this. It inserts the semicolon where
the star would go. Also note the function f there...


FRESH STUFF 2018-10-09:

test_log_sugar_5 needs a ruling. In it we have insertstars == 0 and the statement
'log_x^2(3)' the problem is that that stars logic will never accept that '2(3)'
bit. Can we just assume that the insertstars is wrong there? If someone needs to
have that candy they need to select somethign else than 0 or 3 as insertstars.
Essentially, this could be the same as test_log_sugar_3 where the bit lacks stars
in the given base.

CJS: No objection to this suggestion Matti.  These are "nice to have" but we don't need to do everything.


test_scientific_2 is the syntax supposed to be true instead of false here?


test_spaces_1_insertneeded_andspace and test_spaces_3_insertneeded_andspace
the errors should probably only mention the bit failing not the bit that we
fix in that insert stars logic. Implementation is ready but do we want it to
be so? We can easilly generate warning/error of the bit we fix too.



Chris & Tim,

This is the branch where I try to replace the old regexp pattern based casstring
validation with a parser based one to solve the old issue #324 and to bring
the parser into play to prepare for future compiled PRT evaluation solutions.
Essentially, this branch tries to show that most if not all of the tricks
the old validation had can be replicated with an AST based rule checking and
tree modifications.

The old validation logic is present in this branch as "_old" classes and you can
use 'cli/casstringtester.php' to test inputs, it will test through both systems.
And show you comparisons of the output of each of the combinations of the four
parameters excluding allowed words...

There are some things in the old that will never find a direct match in the new
and some new things that need to be taken into account. Here is a list that
needs to be gone through:

 1. spaces, the old validation assumed that students do not use extra spaces
    and gave plenty of warnings about their use. This was mainly to help
    regexp logic to work with the expressions. The parser throws white space out
    and therefore finding it is a bit more difficult task so we cannot easily
    give similar warnings. But on the other hand do we even need to?

CJS response:  I'd like to have options for students' input as follows:
  - spaces are not permitted
  - allow spaces for implied multiplication.

MH response:
  - allow spaces for implied multiplication is present in the implementation of
    old insert stars logic as is the spaces not permitted logic.
  - There might be a need for the third option, i.e. "don't care" which is
    present in the security='t' case where we just throw things directly to
    the parser.


 2. some old logic "features" are causing trouble and are visible in test cases
    e.g. why did we allow single character function names for students as long
    as they are not at the start or after specific operators... check these ones
    out, especially the '+' vs. '-':

      php ./cli/casstringtester.php --string="f(x)"
      php ./cli/casstringtester.php --string="1-f(x)"
      php ./cli/casstringtester.php --string="1+f(x)"
      php ./cli/casstringtester.php --string="(f(x))"

    there are input test cases like "a/(a(x+1)+2)" and "x^f(x)" that have
    this problem.

    The root cause of that mess is here:
      https://github.com/maths/moodle-qtype_stack/blob/master/stack/cas/casstring.class.php#L1018-L1021

    Naturally, the AST based insert stars can replicate the old behaviour but is
    that desirable? Does the old behaviour even make sense?

CJS response: there is confusion in the old logic, for which I appologise. This is a good time to clean this up.
I suggest options as follows:
  - student defined functions permitted.
  - student definef functions not permitted.
If student defined functions are not permitted then "f(x)"->  f*(x).
This will help with the "Variable_function" error message we currently have.

MH response:
  - student defined functions sounds good but we need to think through its
    implications with other insert stars logic like: xy(x) => x*y(x) or x*y*(x),
    the rule of no function name ending with number probably stays as is.

 3. as a change to general logic insert stars will now always fix stars
    ('s' vs. 't' still applies) but will mark the validity so that a combined
    error statement can be drawn for the whole expression. This due to it being
    simpler to render the whole thing in error messages than to try to find what
    needed to be fixed. This has the inconvenient consequence that most tests
    fail... Related to this, check the toString()-method of the parse nodes.
    Especially, how it can mark '*' ops that have been inserted into the tree...
    Might make some other errors easier to generate and focus...

CJS response:  This sounds sensible.
  If we consider a student's typed expression "invalid", but we can insert *s that is fine.  Sometimes we want to enforce syntax!
  If some tests now fail, then we should update in the light of this changed decision.  (I've done some of this in 7a4627517fcad84c85f2d73e283d68426f855489)

MH response:
  - Indeed we may want to enforce syntax even if we could guess what was meant.
    If we can guess what to fix to go forward we can parse stuff and check what
    else might be wrong at the same time.
  - Some tests tested the internal state of the old system instead of the result
    so changing the, to test the results will be much better. In the case of
    casstring validation testing we should especially avoid checking
    the internal state if the input leads to ParseError.

 4. We could do many things like catch direct divisions by zero at
    the validation phase but how far should we go as each test will need to be
    executed for all or has to have its own parameter to block it.

CJS response: Indeed.  I suggest we re-consider this issue when we are back to the working system.
As before, we will move some things from the CAS to PHP (e.g. division by zero) and some from PHP to the CAS perhaps as it evolves.

MH response:
  - No hurry, I expect that it takes years for us to learn what all we can do
    with this the low hanging fruits like sigfigs target identification will
    easily get done soon. But for example "5*10^-1 as a float" will wait.

 5. Magic identifiers group has grown from 'QMCHAR' etc. to include '%%Is' and
    '%%IS' that are used to transfer information about inserted stars from pre
    parse scope to parse scope. Lets just say that you do not need to understand
    it but it might be of use to know what happens. This ties to point 3.

CJS response:  Can we please refactor as much as possible to have one system for STACK-generated identifiers?
I'm not in love with QMCHAR, etc. and these things should not be edited by users so should not appear in questions.
If we need to change them let's do so.

MH response:
  - Chris, %%IS and %%Is live for very short time inside the parse process and
    get eliminated fast, they never get to Maxima and should not be shown to
    the student. We could even make it so that users could never input them.
  - QMCHAR is one of those things that we can entirely eliminate from the system
    simply by adding the prefix op '?' to the parser (and forbid its use).
  - STACKGRID is also one of those that has no reason to exist in our new world.
  - I would guess we no longer need those identifiers, other than 'nounand' and
    its brethren as we can easily ignore the things they try to mask from regex
    later in the AST processing.


 6. Float identification is quite a bit more robust and we may need to think
    about what is correct as the star insertion in the old system is quite odd
    every now and then:

      php ./cli/casstringtester.php --string="3.2e2"

CJS response: yes.  This is a huge improvement.

 7. check_external_forbidden_words and the other will probably work just fine
    but it might be sensible to cache the words present in the expression during
    the validation...

In addition there are technical details:

 1. The parser comes from qtype_stateful and not even from its PHP side instead
    it is a side product of that question type's authoring tools, we must make
    sure that we do not edit it on STACKs end if it needs to be edited
    the modifications must be passed to qtype_stateful. Same applies to
    the PHP-classes matching the nodes in the AST the parser generates.

CJS: noted.  I hope we can include stateful soon anyway.

MH response:
  - I do believe that Stateful should never be included into STACK, it could be
    packaged with it but STACK should be separate as the things that make STACK
    great would break if we tried to accommodate Stateful in the same context.
  - Essentially, Stateful and STACK share much and Stateful uses the engine of
    STACK but they differ quite a lot in places where trying to fit both would
    make neither work well.


 2. mbstring, the parser generator uses mbstring functions to deal with UTF-8,
    Moodle recommends but does not require mbstring, for this reason we may
    need to modify the parser by changing its direct use of mbstring in about
    five places to go through Moodles core_text. Although I do think that that
    will be expensive as that will add one more layer to quite a lot of function
    calls and it would probably make more sense for us to instead require
    mbstring to be installed.

CJS: noted.  We have to think of the ILIAS people as well here.

MH response:
  - We should benchmark things if we modify the parser to use core_text instead
    of mbstring directly, I have a feeling that there would be a major overhead
    there. Just look at the code of core_text and what it does if you have to
    call e.g. some regex through it a few tens of thousands times.



Tools to mark the allowed/forbidden words lists:
 1. Turn the current array to JSON.
 2. Load it to stack-maxima with data:stackjson_parse(blaah), you may need to
    filter some things out like the operators that make no sense...
 3. Get the identifiers for functions defined in the libraries we have:

  loadedfunnames:setify(map(op,functions));

 4. Populate the map, by trying the identifiers and interpreting the errors.

 for key in stackmap_keys(data) do (
  _val: errcatch(parse_string(sconcat("(",key,");"))),
  if is(_val=[]) then data:stackmap_set(data, key, "bad")
  elseif constantp(_val[1]) then data:stackmap_set(data, key, "constant")
  elseif elementp(_val[1], loadedfunnames) then data:stackmap_set(data, key, "function")
  elseif symbolp(_val[1]) and featurep(_val[1], noun) then data:stackmap_set(data, key, "nounfunction")
  elseif symbolp(_val[1]) then (
    _valb: errcatch(apply(_val[1], [])),

    if is(_valb=[]) and not is(ssearch("arguments", error[1])=false) then data:stackmap_set(data, key, "function")
    elseif ?fboundp(_val[1]) then data:stackmap_set(data, key, "systemfunction")
    elseif elementp(evflag, setify(apply(properties,[_val[1]]))) then data:stackmap_set(data, key, "evflag")
    elseif elementp("system value", setify(apply(properties,[_val[1]]))) then data:stackmap_set(data, key, "property")
    else data:stackmap_set(data, key, "symbol")
  )
 );

 5. Means of identifying variables and functions from the maxima source:

 > tar xvf maxima-5.41.0.tar.gz
 > cd maxima-5.41.0
 // These are the functions defined, but not all the functions some lisp functions do still exist. like trigs... Look into src/mlisp.lisp for some hints.
 // Note that these are the core stuff, you need to also include stuff from contrib.
 > grep "(defmfun \\$" src/* src/*/* src/*/*/* src/*/*/*/* -hs | sort | cut -f2 -d $ | cut -f1 -d ' '
 // And these are the variables, some are constants but that can be checked in Maxima.
 > grep "(defmvar \\$" src/* src/*/* src/*/*/* src/*/*/*/* -hs | sort | cut -f2 -d $ | cut -f1 -d ' '

 6. On the maxima side you obviously do as follows:

 // Use the functions list that contains all the functions defined using Maxima side function definitions.
 > funnames:setify(map(op,functions));
 // values tells things that have been given value, so those are obviously variables that need to be kept safe
 > values;

 7. Actually all of those tricks do not work as there are special cases everywhere,
    just look at delta(x) it is impossible to catch or the various rule based functions.

    The only somewhat sane way we have left is to play with the documentation files:

    > tar xvf maxima-5.41.0.tar.gz
    > cd maxima-5.41.0/doc/info
    > grep '^ \-\- .*: .*' -shI * | grep -v 'an error. To debug'

    -- Function: integrate (<expr>, <x>)
    -- Function: integrate (<expr>, <x>, <a>, <b>)
    -- Option variable: integrate_use_rootsof
    -- Function: integerp (<expr>)
    -- Function: askinteger (<expr>, integer)
    -- Function: askinteger (<expr>)
    -- Function: askinteger (<expr>, even)
    -- Function: askinteger (<expr>, odd)
    -- Function: integerp (&lt;expr&gt;) .....

    That is an output that can be parsed further quite easily. And the count of
    output lines is quite near the expected 2.5k vs. 4k identified by Maxima
    command line trickery that also catches unbound local variables inside logic
    and lisp.
